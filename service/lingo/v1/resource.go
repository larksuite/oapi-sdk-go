// Code generated by Lark OpenAPI.

package larklingo

import (
	"bytes"
	"context"
	"net/http"

	"github.com/larksuite/oapi-sdk-go/v3/core"
)

type V1 struct {
	Classification *classification // classification
	Draft          *draft          // draft
	Entity         *entity         // entity
	File           *file           // file
	Repo           *repo           // repo
}

func New(config *larkcore.Config) *V1 {
	return &V1{
		Classification: &classification{config: config},
		Draft:          &draft{config: config},
		Entity:         &entity{config: config},
		File:           &file{config: config},
		Repo:           &repo{config: config},
	}
}

type classification struct {
	config *larkcore.Config
}
type draft struct {
	config *larkcore.Config
}
type entity struct {
	config *larkcore.Config
}
type file struct {
	config *larkcore.Config
}
type repo struct {
	config *larkcore.Config
}

// List
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=list&project=lingo&resource=classification&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/list_classification.go
func (c *classification) List(ctx context.Context, req *ListClassificationReq, options ...larkcore.RequestOptionFunc) (*ListClassificationResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/classifications"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, c.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListClassificationResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, c.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (c *classification) ListByIterator(ctx context.Context, req *ListClassificationReq, options ...larkcore.RequestOptionFunc) (*ListClassificationIterator, error) {
	return &ListClassificationIterator{
		ctx:      ctx,
		req:      req,
		listFunc: c.List,
		options:  options,
		limit:    req.Limit}, nil
}

// Create
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=create&project=lingo&resource=draft&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/create_draft.go
func (d *draft) Create(ctx context.Context, req *CreateDraftReq, options ...larkcore.RequestOptionFunc) (*CreateDraftResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/drafts"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, d.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateDraftResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, d.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Update
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=update&project=lingo&resource=draft&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/update_draft.go
func (d *draft) Update(ctx context.Context, req *UpdateDraftReq, options ...larkcore.RequestOptionFunc) (*UpdateDraftResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/drafts/:draft_id"
	apiReq.HttpMethod = http.MethodPut
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, d.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UpdateDraftResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, d.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Create
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=create&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/create_entity.go
func (e *entity) Create(ctx context.Context, req *CreateEntityReq, options ...larkcore.RequestOptionFunc) (*CreateEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &CreateEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Delete
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=delete&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/delete_entity.go
func (e *entity) Delete(ctx context.Context, req *DeleteEntityReq, options ...larkcore.RequestOptionFunc) (*DeleteEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/:entity_id"
	apiReq.HttpMethod = http.MethodDelete
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DeleteEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Get
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=get&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/get_entity.go
func (e *entity) Get(ctx context.Context, req *GetEntityReq, options ...larkcore.RequestOptionFunc) (*GetEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/:entity_id"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &GetEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Highlight
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=highlight&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/highlight_entity.go
func (e *entity) Highlight(ctx context.Context, req *HighlightEntityReq, options ...larkcore.RequestOptionFunc) (*HighlightEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/highlight"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &HighlightEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=list&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/list_entity.go
func (e *entity) List(ctx context.Context, req *ListEntityReq, options ...larkcore.RequestOptionFunc) (*ListEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (e *entity) ListByIterator(ctx context.Context, req *ListEntityReq, options ...larkcore.RequestOptionFunc) (*ListEntityIterator, error) {
	return &ListEntityIterator{
		ctx:      ctx,
		req:      req,
		listFunc: e.List,
		options:  options,
		limit:    req.Limit}, nil
}

// Match
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=match&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/match_entity.go
func (e *entity) Match(ctx context.Context, req *MatchEntityReq, options ...larkcore.RequestOptionFunc) (*MatchEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/match"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeUser, larkcore.AccessTokenTypeTenant}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &MatchEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Search
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=search&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/search_entity.go
func (e *entity) Search(ctx context.Context, req *SearchEntityReq, options ...larkcore.RequestOptionFunc) (*SearchEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/search"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &SearchEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
func (e *entity) SearchByIterator(ctx context.Context, req *SearchEntityReq, options ...larkcore.RequestOptionFunc) (*SearchEntityIterator, error) {
	return &SearchEntityIterator{
		ctx:      ctx,
		req:      req,
		listFunc: e.Search,
		options:  options,
		limit:    req.Limit}, nil
}

// Update
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=update&project=lingo&resource=entity&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/update_entity.go
func (e *entity) Update(ctx context.Context, req *UpdateEntityReq, options ...larkcore.RequestOptionFunc) (*UpdateEntityResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/entities/:entity_id"
	apiReq.HttpMethod = http.MethodPut
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, e.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UpdateEntityResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, e.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Download
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=download&project=lingo&resource=file&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/download_file.go
func (f *file) Download(ctx context.Context, req *DownloadFileReq, options ...larkcore.RequestOptionFunc) (*DownloadFileResp, error) {
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/files/:file_token/download"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &DownloadFileResp{ApiResp: apiResp}
	// 如果是下载，则设置响应结果
	if apiResp.StatusCode == http.StatusOK {
		resp.File = bytes.NewBuffer(apiResp.RawBody)
		resp.FileName = larkcore.FileNameByHeader(apiResp.Header)
		return resp, err
	}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// Upload
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=upload&project=lingo&resource=file&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/upload_file.go
func (f *file) Upload(ctx context.Context, req *UploadFileReq, options ...larkcore.RequestOptionFunc) (*UploadFileResp, error) {
	options = append(options, larkcore.WithFileUpload())
	// 发起请求
	apiReq := req.apiReq
	apiReq.ApiPath = "/open-apis/lingo/v1/files/upload"
	apiReq.HttpMethod = http.MethodPost
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, f.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &UploadFileResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, f.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}

// List
//
// -
//
// - 官网API文档链接:https://open.feishu.cn/api-explorer?from=op_doc_tab&apiName=list&project=lingo&resource=repo&version=v1
//
// - 使用Demo链接:https://github.com/larksuite/oapi-sdk-go/tree/v3_main/sample/apiall/lingov1/list_repo.go
func (r *repo) List(ctx context.Context, options ...larkcore.RequestOptionFunc) (*ListRepoResp, error) {
	// 发起请求
	apiReq := &larkcore.ApiReq{
		PathParams:  larkcore.PathParams{},
		QueryParams: larkcore.QueryParams{},
	}
	apiReq.ApiPath = "/open-apis/lingo/v1/repos"
	apiReq.HttpMethod = http.MethodGet
	apiReq.SupportedAccessTokenTypes = []larkcore.AccessTokenType{larkcore.AccessTokenTypeTenant, larkcore.AccessTokenTypeUser}
	apiResp, err := larkcore.Request(ctx, apiReq, r.config, options...)
	if err != nil {
		return nil, err
	}
	// 反序列响应结果
	resp := &ListRepoResp{ApiResp: apiResp}
	err = apiResp.JSONUnmarshalBody(resp, r.config)
	if err != nil {
		return nil, err
	}
	return resp, err
}
