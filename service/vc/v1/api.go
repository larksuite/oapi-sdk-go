// Code generated by lark suite oapi sdk gen
package v1

import (
	"github.com/larksuite/oapi-sdk-go/api"
	"github.com/larksuite/oapi-sdk-go/api/core/request"
	"github.com/larksuite/oapi-sdk-go/api/core/response"
	"github.com/larksuite/oapi-sdk-go/core"
	"github.com/larksuite/oapi-sdk-go/core/config"
)

type Service struct {
	conf              *config.Config
	Meetings          *MeetingService
	MeetingRecordings *MeetingRecordingService
	Reports           *ReportService
	Reserves          *ReserveService
	RoomConfigs       *RoomConfigService
}

func NewService(conf *config.Config) *Service {
	s := &Service{
		conf: conf,
	}
	s.Meetings = newMeetingService(s)
	s.MeetingRecordings = newMeetingRecordingService(s)
	s.Reports = newReportService(s)
	s.Reserves = newReserveService(s)
	s.RoomConfigs = newRoomConfigService(s)
	return s
}

type MeetingService struct {
	service *Service
}

func newMeetingService(service *Service) *MeetingService {
	return &MeetingService{
		service: service,
	}
}

type MeetingRecordingService struct {
	service *Service
}

func newMeetingRecordingService(service *Service) *MeetingRecordingService {
	return &MeetingRecordingService{
		service: service,
	}
}

type ReportService struct {
	service *Service
}

func newReportService(service *Service) *ReportService {
	return &ReportService{
		service: service,
	}
}

type ReserveService struct {
	service *Service
}

func newReserveService(service *Service) *ReserveService {
	return &ReserveService{
		service: service,
	}
}

type RoomConfigService struct {
	service *Service
}

func newRoomConfigService(service *Service) *RoomConfigService {
	return &RoomConfigService{
		service: service,
	}
}

type MeetingInviteReqCall struct {
	ctx         *core.Context
	meetings    *MeetingService
	body        *MeetingInviteReqBody
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *MeetingInviteReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}
func (rc *MeetingInviteReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *MeetingInviteReqCall) Do() (*MeetingInviteResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &MeetingInviteResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/invite", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) Invite(ctx *core.Context, body *MeetingInviteReqBody, optFns ...request.OptFn) *MeetingInviteReqCall {
	return &MeetingInviteReqCall{
		ctx:         ctx,
		meetings:    meetings,
		body:        body,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type MeetingSetHostReqCall struct {
	ctx         *core.Context
	meetings    *MeetingService
	body        *MeetingSetHostReqBody
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *MeetingSetHostReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}
func (rc *MeetingSetHostReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *MeetingSetHostReqCall) Do() (*MeetingSetHostResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &MeetingSetHostResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/set_host", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser, request.AccessTokenTypeTenant}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) SetHost(ctx *core.Context, body *MeetingSetHostReqBody, optFns ...request.OptFn) *MeetingSetHostReqCall {
	return &MeetingSetHostReqCall{
		ctx:         ctx,
		meetings:    meetings,
		body:        body,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type MeetingEndReqCall struct {
	ctx        *core.Context
	meetings   *MeetingService
	pathParams map[string]interface{}
	optFns     []request.OptFn
}

func (rc *MeetingEndReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}

func (rc *MeetingEndReqCall) Do() (*response.NoData, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/end", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) End(ctx *core.Context, optFns ...request.OptFn) *MeetingEndReqCall {
	return &MeetingEndReqCall{
		ctx:        ctx,
		meetings:   meetings,
		pathParams: map[string]interface{}{},
		optFns:     optFns,
	}
}

type MeetingGetReqCall struct {
	ctx         *core.Context
	meetings    *MeetingService
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *MeetingGetReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}
func (rc *MeetingGetReqCall) SetWithParticipants(withParticipants bool) {
	rc.queryParams["with_participants"] = withParticipants
}
func (rc *MeetingGetReqCall) SetWithMeetingAbility(withMeetingAbility bool) {
	rc.queryParams["with_meeting_ability"] = withMeetingAbility
}
func (rc *MeetingGetReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *MeetingGetReqCall) Do() (*MeetingGetResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &MeetingGetResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeUser, request.AccessTokenTypeTenant}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) Get(ctx *core.Context, optFns ...request.OptFn) *MeetingGetReqCall {
	return &MeetingGetReqCall{
		ctx:         ctx,
		meetings:    meetings,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type MeetingKickoutReqCall struct {
	ctx         *core.Context
	meetings    *MeetingService
	body        *MeetingKickoutReqBody
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *MeetingKickoutReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}
func (rc *MeetingKickoutReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *MeetingKickoutReqCall) Do() (*MeetingKickoutResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &MeetingKickoutResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/kickout", "POST",
		[]request.AccessTokenType{request.AccessTokenTypeTenant}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) Kickout(ctx *core.Context, body *MeetingKickoutReqBody, optFns ...request.OptFn) *MeetingKickoutReqCall {
	return &MeetingKickoutReqCall{
		ctx:         ctx,
		meetings:    meetings,
		body:        body,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type MeetingListByNoReqCall struct {
	ctx         *core.Context
	meetings    *MeetingService
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *MeetingListByNoReqCall) SetMeetingNo(meetingNo string) {
	rc.queryParams["meeting_no"] = meetingNo
}
func (rc *MeetingListByNoReqCall) SetStartTime(startTime int64) {
	rc.queryParams["start_time"] = startTime
}
func (rc *MeetingListByNoReqCall) SetEndTime(endTime int64) {
	rc.queryParams["end_time"] = endTime
}
func (rc *MeetingListByNoReqCall) SetPageToken(pageToken string) {
	rc.queryParams["page_token"] = pageToken
}
func (rc *MeetingListByNoReqCall) SetPageSize(pageSize int) {
	rc.queryParams["page_size"] = pageSize
}

func (rc *MeetingListByNoReqCall) Do() (*MeetingListByNoResult, error) {
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &MeetingListByNoResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/list_by_no", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeUser, request.AccessTokenTypeTenant}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetings.service.conf, req)
	return result, err
}

func (meetings *MeetingService) ListByNo(ctx *core.Context, optFns ...request.OptFn) *MeetingListByNoReqCall {
	return &MeetingListByNoReqCall{
		ctx:         ctx,
		meetings:    meetings,
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type MeetingRecordingGetReqCall struct {
	ctx               *core.Context
	meetingRecordings *MeetingRecordingService
	pathParams        map[string]interface{}
	optFns            []request.OptFn
}

func (rc *MeetingRecordingGetReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}

func (rc *MeetingRecordingGetReqCall) Do() (*MeetingRecordingGetResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	var result = &MeetingRecordingGetResult{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/recording", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetingRecordings.service.conf, req)
	return result, err
}

func (meetingRecordings *MeetingRecordingService) Get(ctx *core.Context, optFns ...request.OptFn) *MeetingRecordingGetReqCall {
	return &MeetingRecordingGetReqCall{
		ctx:               ctx,
		meetingRecordings: meetingRecordings,
		pathParams:        map[string]interface{}{},
		optFns:            optFns,
	}
}

type MeetingRecordingStopReqCall struct {
	ctx               *core.Context
	meetingRecordings *MeetingRecordingService
	pathParams        map[string]interface{}
	optFns            []request.OptFn
}

func (rc *MeetingRecordingStopReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}

func (rc *MeetingRecordingStopReqCall) Do() (*response.NoData, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/recording/stop", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetingRecordings.service.conf, req)
	return result, err
}

func (meetingRecordings *MeetingRecordingService) Stop(ctx *core.Context, optFns ...request.OptFn) *MeetingRecordingStopReqCall {
	return &MeetingRecordingStopReqCall{
		ctx:               ctx,
		meetingRecordings: meetingRecordings,
		pathParams:        map[string]interface{}{},
		optFns:            optFns,
	}
}

type MeetingRecordingSetPermissionReqCall struct {
	ctx               *core.Context
	meetingRecordings *MeetingRecordingService
	body              *MeetingRecordingSetPermissionReqBody
	pathParams        map[string]interface{}
	queryParams       map[string]interface{}
	optFns            []request.OptFn
}

func (rc *MeetingRecordingSetPermissionReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}
func (rc *MeetingRecordingSetPermissionReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *MeetingRecordingSetPermissionReqCall) Do() (*response.NoData, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/recording/set_permission", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetingRecordings.service.conf, req)
	return result, err
}

func (meetingRecordings *MeetingRecordingService) SetPermission(ctx *core.Context, body *MeetingRecordingSetPermissionReqBody, optFns ...request.OptFn) *MeetingRecordingSetPermissionReqCall {
	return &MeetingRecordingSetPermissionReqCall{
		ctx:               ctx,
		meetingRecordings: meetingRecordings,
		body:              body,
		pathParams:        map[string]interface{}{},
		queryParams:       map[string]interface{}{},
		optFns:            optFns,
	}
}

type MeetingRecordingStartReqCall struct {
	ctx               *core.Context
	meetingRecordings *MeetingRecordingService
	body              *MeetingRecordingStartReqBody
	pathParams        map[string]interface{}
	optFns            []request.OptFn
}

func (rc *MeetingRecordingStartReqCall) SetMeetingId(meetingId int64) {
	rc.pathParams["meeting_id"] = meetingId
}

func (rc *MeetingRecordingStartReqCall) Do() (*response.NoData, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/meetings/:meeting_id/recording/start", "PATCH",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.meetingRecordings.service.conf, req)
	return result, err
}

func (meetingRecordings *MeetingRecordingService) Start(ctx *core.Context, body *MeetingRecordingStartReqBody, optFns ...request.OptFn) *MeetingRecordingStartReqCall {
	return &MeetingRecordingStartReqCall{
		ctx:               ctx,
		meetingRecordings: meetingRecordings,
		body:              body,
		pathParams:        map[string]interface{}{},
		optFns:            optFns,
	}
}

type ReportGetTopUserReqCall struct {
	ctx         *core.Context
	reports     *ReportService
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReportGetTopUserReqCall) SetStartTime(startTime int64) {
	rc.queryParams["start_time"] = startTime
}
func (rc *ReportGetTopUserReqCall) SetEndTime(endTime int64) {
	rc.queryParams["end_time"] = endTime
}
func (rc *ReportGetTopUserReqCall) SetLimit(limit int) {
	rc.queryParams["limit"] = limit
}
func (rc *ReportGetTopUserReqCall) SetOrderBy(orderBy int) {
	rc.queryParams["order_by"] = orderBy
}
func (rc *ReportGetTopUserReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *ReportGetTopUserReqCall) Do() (*ReportGetTopUserResult, error) {
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReportGetTopUserResult{}
	req := request.NewRequest("/open-apis/vc/v1/reports/get_top_user", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeTenant}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reports.service.conf, req)
	return result, err
}

func (reports *ReportService) GetTopUser(ctx *core.Context, optFns ...request.OptFn) *ReportGetTopUserReqCall {
	return &ReportGetTopUserReqCall{
		ctx:         ctx,
		reports:     reports,
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReportGetDailyReqCall struct {
	ctx         *core.Context
	reports     *ReportService
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReportGetDailyReqCall) SetStartTime(startTime int64) {
	rc.queryParams["start_time"] = startTime
}
func (rc *ReportGetDailyReqCall) SetEndTime(endTime int64) {
	rc.queryParams["end_time"] = endTime
}

func (rc *ReportGetDailyReqCall) Do() (*ReportGetDailyResult, error) {
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReportGetDailyResult{}
	req := request.NewRequest("/open-apis/vc/v1/reports/get_daily", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeTenant}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reports.service.conf, req)
	return result, err
}

func (reports *ReportService) GetDaily(ctx *core.Context, optFns ...request.OptFn) *ReportGetDailyReqCall {
	return &ReportGetDailyReqCall{
		ctx:         ctx,
		reports:     reports,
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReserveUpdateReqCall struct {
	ctx         *core.Context
	reserves    *ReserveService
	body        *ReserveUpdateReqBody
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReserveUpdateReqCall) SetReserveId(reserveId int64) {
	rc.pathParams["reserve_id"] = reserveId
}
func (rc *ReserveUpdateReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *ReserveUpdateReqCall) Do() (*ReserveUpdateResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReserveUpdateResult{}
	req := request.NewRequest("/open-apis/vc/v1/reserves/:reserve_id", "PUT",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reserves.service.conf, req)
	return result, err
}

func (reserves *ReserveService) Update(ctx *core.Context, body *ReserveUpdateReqBody, optFns ...request.OptFn) *ReserveUpdateReqCall {
	return &ReserveUpdateReqCall{
		ctx:         ctx,
		reserves:    reserves,
		body:        body,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReserveApplyReqCall struct {
	ctx         *core.Context
	reserves    *ReserveService
	body        *ReserveApplyReqBody
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReserveApplyReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *ReserveApplyReqCall) Do() (*ReserveApplyResult, error) {
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReserveApplyResult{}
	req := request.NewRequest("/open-apis/vc/v1/reserves/apply", "POST",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reserves.service.conf, req)
	return result, err
}

func (reserves *ReserveService) Apply(ctx *core.Context, body *ReserveApplyReqBody, optFns ...request.OptFn) *ReserveApplyReqCall {
	return &ReserveApplyReqCall{
		ctx:         ctx,
		reserves:    reserves,
		body:        body,
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReserveGetReqCall struct {
	ctx         *core.Context
	reserves    *ReserveService
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReserveGetReqCall) SetReserveId(reserveId int64) {
	rc.pathParams["reserve_id"] = reserveId
}
func (rc *ReserveGetReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *ReserveGetReqCall) Do() (*ReserveGetResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReserveGetResult{}
	req := request.NewRequest("/open-apis/vc/v1/reserves/:reserve_id", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reserves.service.conf, req)
	return result, err
}

func (reserves *ReserveService) Get(ctx *core.Context, optFns ...request.OptFn) *ReserveGetReqCall {
	return &ReserveGetReqCall{
		ctx:         ctx,
		reserves:    reserves,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReserveGetActiveMeetingReqCall struct {
	ctx         *core.Context
	reserves    *ReserveService
	pathParams  map[string]interface{}
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *ReserveGetActiveMeetingReqCall) SetReserveId(reserveId int64) {
	rc.pathParams["reserve_id"] = reserveId
}
func (rc *ReserveGetActiveMeetingReqCall) SetWithParticipants(withParticipants bool) {
	rc.queryParams["with_participants"] = withParticipants
}
func (rc *ReserveGetActiveMeetingReqCall) SetUserIdType(userIdType string) {
	rc.queryParams["user_id_type"] = userIdType
}

func (rc *ReserveGetActiveMeetingReqCall) Do() (*ReserveGetActiveMeetingResult, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &ReserveGetActiveMeetingResult{}
	req := request.NewRequest("/open-apis/vc/v1/reserves/:reserve_id/get_active_meeting", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reserves.service.conf, req)
	return result, err
}

func (reserves *ReserveService) GetActiveMeeting(ctx *core.Context, optFns ...request.OptFn) *ReserveGetActiveMeetingReqCall {
	return &ReserveGetActiveMeetingReqCall{
		ctx:         ctx,
		reserves:    reserves,
		pathParams:  map[string]interface{}{},
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type ReserveDeleteReqCall struct {
	ctx        *core.Context
	reserves   *ReserveService
	pathParams map[string]interface{}
	optFns     []request.OptFn
}

func (rc *ReserveDeleteReqCall) SetReserveId(reserveId int64) {
	rc.pathParams["reserve_id"] = reserveId
}

func (rc *ReserveDeleteReqCall) Do() (*response.NoData, error) {
	rc.optFns = append(rc.optFns, request.SetPathParams(rc.pathParams))
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/reserves/:reserve_id", "DELETE",
		[]request.AccessTokenType{request.AccessTokenTypeUser}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.reserves.service.conf, req)
	return result, err
}

func (reserves *ReserveService) Delete(ctx *core.Context, optFns ...request.OptFn) *ReserveDeleteReqCall {
	return &ReserveDeleteReqCall{
		ctx:        ctx,
		reserves:   reserves,
		pathParams: map[string]interface{}{},
		optFns:     optFns,
	}
}

type RoomConfigQueryReqCall struct {
	ctx         *core.Context
	roomConfigs *RoomConfigService
	queryParams map[string]interface{}
	optFns      []request.OptFn
}

func (rc *RoomConfigQueryReqCall) SetScope(scope int) {
	rc.queryParams["scope"] = scope
}
func (rc *RoomConfigQueryReqCall) SetCountryId(countryId string) {
	rc.queryParams["country_id"] = countryId
}
func (rc *RoomConfigQueryReqCall) SetDistrictId(districtId string) {
	rc.queryParams["district_id"] = districtId
}
func (rc *RoomConfigQueryReqCall) SetBuildingId(buildingId string) {
	rc.queryParams["building_id"] = buildingId
}
func (rc *RoomConfigQueryReqCall) SetFloorName(floorName string) {
	rc.queryParams["floor_name"] = floorName
}
func (rc *RoomConfigQueryReqCall) SetRoomId(roomId string) {
	rc.queryParams["room_id"] = roomId
}

func (rc *RoomConfigQueryReqCall) Do() (*RoomConfig, error) {
	rc.optFns = append(rc.optFns, request.SetQueryParams(rc.queryParams))
	var result = &RoomConfig{}
	req := request.NewRequest("/open-apis/vc/v1/room_configs/query", "GET",
		[]request.AccessTokenType{request.AccessTokenTypeTenant}, nil, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.roomConfigs.service.conf, req)
	return result, err
}

func (roomConfigs *RoomConfigService) Query(ctx *core.Context, optFns ...request.OptFn) *RoomConfigQueryReqCall {
	return &RoomConfigQueryReqCall{
		ctx:         ctx,
		roomConfigs: roomConfigs,
		queryParams: map[string]interface{}{},
		optFns:      optFns,
	}
}

type RoomConfigSetReqCall struct {
	ctx         *core.Context
	roomConfigs *RoomConfigService
	body        *RoomConfigSetReqBody
	optFns      []request.OptFn
}

func (rc *RoomConfigSetReqCall) Do() (*response.NoData, error) {
	var result = &response.NoData{}
	req := request.NewRequest("/open-apis/vc/v1/room_configs/set", "POST",
		[]request.AccessTokenType{request.AccessTokenTypeTenant}, rc.body, result, rc.optFns...)
	err := api.Send(rc.ctx, rc.roomConfigs.service.conf, req)
	return result, err
}

func (roomConfigs *RoomConfigService) Set(ctx *core.Context, body *RoomConfigSetReqBody, optFns ...request.OptFn) *RoomConfigSetReqCall {
	return &RoomConfigSetReqCall{
		ctx:         ctx,
		roomConfigs: roomConfigs,
		body:        body,
		optFns:      optFns,
	}
}
